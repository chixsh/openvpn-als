<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="en-US">
<head>
<title>yGuard 1.3.1 - Ant Java Obfuscator - Documentation</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<meta http-equiv="content-language" content="en">
<meta http-equiv="language" content="en">
<meta http-equiv="reply-to" content="yguard@yWorks.com">
<meta name="audience" content="all">
<meta name="classification" content="software">
<meta name="copyright" content="Copyright &copy; 2002-2003 yWorks. All Rights Reserved.">
<meta name="distribution" content="global">
<meta name="publisher" content="yWorks, http://www.yWorks.com">
<meta name="rating" content="Safe For Kids">
</head>
<body> 
 <p>
 This document explains how to use the yGuard Java obfuscation software together with Ant. yGuard
 is a product of <a href="http://www.yworks.com/">yWorks GmbH</a>, creator of
 the outstanding Java<sup><font size="-2">TM</font></sup> graph visualization framework
 <a href="http://www.yworks.com/products/yfiles">yFiles</a> and other fine
 <a href="http://www.yworks.com/products/">products</a>.
 </p>

    <h1>yGuard Ant Task Documentation</h1>
    <h2>Contents</h2>
    <div class="standardtext">
        <ul>
            <li><a href="#introduction">Installation</a></li>
            <li><a href="#dtd">DTD used for Ant <code>&lt;obfuscate></code></a></li>
            <li><a href="#obfuscate">The <code>obfuscate</code> Element</a></li>
            <li><a href="#property">The <code>property</code> Elements</a></li>
            <li><a href="#externalclasses">The <code>externalclasses</code> Element</a></li>
            <li><a href="#inoutpair">The <code>inoutpair</code> Elements</a></li>
            <li><a href="#expose">The <code>expose</code> Element</a></li>
            <li><a href="#class">The <code>class</code> Elements</a></li>
            <li><a href="#method">The <code>method</code> Elements</a></li>
            <li><a href="#field">The <code>field</code> Elements</a></li>
            <li><a href="#adjust">The <code>adjust</code> Elements</a></li>
            <li><a href="#map">The <code>map</code> Element</a></li>
            <li><a href="#patch">Generating Patch Jars</a></li>
            <li><a href="#examples">Complete Examples</a></li>
            <li><a href="#hints">General Hints</a></li>
            <li><a href="#problems">Problems and Bug Reports</a></li>
        </ul>
    </div>

      <a name="introduction"></a>
<h1>Installation</h1>
<div class="standardtext">
 In order to make use of yGuard's <code>obfuscate</code> task you must have Ant properly installed and configured
 to run it. After <a href="http://www.yworks.com/products/yguard/">downloading</a>
 and extracting the jar file
 (<code>yguard.jar</code>), place it in a path near to your build script. You may use
 absolute paths, but in the following example, we expect the jar file to lie
 in the same directory as your build file.
 </p>
 <p>
 In order the get the Ant task running you should insert a couple of lines in
 your build script (<code>build.xml</code>): 
 </p>
 <pre>
  &lt;taskdef name="obfuscate" 
      classname="com.yworks.yguard.ObfuscatorTask" 
      classpath="yguard.jar"/>

  &lt;target name="obfuscate">
    &lt;obfuscate>
      &lt;!-- modify obfuscate element attributes and 
             insert your statements here -->
    &lt;/obfuscate>
  &lt;/target>
 </pre>
<p>
    Alternatively, you can place the <code>taskdef</code> element inside the
target:
</p>
 <pre>
  &lt;target name="obfuscate">
    &lt;taskdef name="obfuscate" 
        classname="com.yworks.yguard.ObfuscatorTask" 
        classpath="yguard.jar"/>
    &lt;obfuscate>
      &lt;!-- modify obfuscate element attributes and 
             insert your statements here -->
    &lt;/obfuscate>
  &lt;/target>
 </pre>
 <a name="dtd"></a>
</div>
<p>
    For a complete <code>build.xml</code> file have a look at the 
    <a href="#examples">examples section</a>.
</p>
 <h1>DTD used for Ant <code>&lt;obfuscate></code></h1>
<div class="standardtext">
 The obfuscation process can completely be configured inside your Ant script.
 The following DTD should be used in it (please note that this is for information purposes only, 
 i.e. you do not have to include the following lines anywhere):
 </p>

 <pre>
  &lt;!ELEMENT obfuscate (inoutpair+,externalclasses?,
                          property*,patch?,expose?,map?,adjust*)>
  &lt;!ATTLIST obfuscate
      mainclass CDATA #IMPLIED
      logfile CDATA #IMPLIED
      conservemanifest CDATA #IMPLIED
      replaceClassNameStrings CDATA #IMPLIED
   >

  &lt;!ELEMENT inoutpair EMPTY>
  &lt;!ATTLIST inoutpair
      in CDATA #REQUIRED
      out CDATA #REQUIRED
   >


  &lt;!ELEMENT externalclasses ANY>
  &lt;!-- the externalclasses element is used just like ant's classpath 
          element. See the Ant documentation for further details-->

  &lt;!ELEMENT property EMPTY>
  &lt;!ATTLIST property
      name CDATA #REQUIRED
      value CDATA #REQUIRED
   >
  
  &lt;!ELEMENT patch (class)*>

  &lt;!ELEMENT expose (class|method|field)*>
  &lt;!ATTLIST expose
      linenumbertable CDATA #IMPLIED
      localvariabletable CDATA #IMPLIED
      sourcefile CDATA #IMPLIED
   >

  &lt;!ELEMENT class (patternset)?>
  &lt;!ATTLIST class
      classes CDATA #IMPLIED
      methods CDATA #IMPLIED
      fields CDATA #IMPLIED
      name CDATA #REQUIRED
      map CDATA #IMPLIED
  >

  &lt;!ELEMENT method (patternset)?>
  &lt;!ATTLIST method
      class CDATA #IMPLIED
      name CDATA #REQUIRED
      map CDATA #IMPLIED
   >

  &lt;!ELEMENT field (patternset)?>
  &lt;!ATTLIST field
      class CDATA #IMPLIED
      name CDATA #REQUIRED
      map CDATA #IMPLIED
   >


  &lt;!ELEMENT adjust ANY>
  &lt;!-- the adjust element is used just like ant's fileset 
          element. See the Ant documentation for further details-->
  
  &lt;!ATTLIST adjust
      replaceName CDATA #IMPLIED
      replaceContent CDATA #IMPLIED
      replacePath CDATA #IMPLIED
   >

  &lt;!ELEMENT map (class|method|field|package)*>

  &lt;!ELEMENT package EMPTY>
  &lt;!ATTLIST package
      name CDATA #REQUIRED
      map CDATA #REQUIRED
   >


 </pre>
 <p>
 <b>Attention</b> users of IDEs that "support" the creation of Ant files (e.g. IDEA's IntelliJ):
 Your IDE may indicate some errors inside your ANT file when you use yGuard specific
 elements. This is because the IDE does not know about the DTD used by yGuard. However
 this is not a real problem, since the Ant file should nevertheless work as expected.
 </p>
  <p>
 The basic idea is, that all elements will be obfuscated by this task.
 You have to specify all classes, methods and fields that should be exposed,
 i.e. that will <b>not</b> be obfuscated. There are different use cases, where you
 sometimes want to expose or simply just have to expose some elements.
 See the <a href="#hints">general hints</a> at the end of this text for more information.
 This can be achieved by using both
 the expose element and the mainclass attribute of the obfuscate element.
 </p>
</div>
  <a name="obfuscate"></a>
 <h1>The <code>obfuscate</code> Element</h1>
<div class="standardtext">
 <p>The following attributes can be specified in the <code>obfuscate</code> element.
 </p>
 <ul>
  <li><code>mainclass</code> can be used as a shortcut to specify the mainclass 
  of your application. Both the class name and the main method will not be 
  obfuscated.
  </li>
  <li><code>logfile</code> determines the name of the logfile that is generated
  during the obfuscation process. The logfile contains information about the
  mappings, the obfuscator generates as well as any warnings.
  <br>
  If the name ends with a ".gz", yGuard will automatically create a gzipped version
  of the file which saves a lot of space.
  </li>
  <li><code>conservemanifest</code> is a boolean attribute (valid values: <code>true</code>/<code>false</code>)
  that determines whether the manifest file of the jars should be left untouched
  by the obfuscator. If set to <code>false</code> (the default), the manifest 
  will be modified to reflect the new message digests.
  <li><code>replaceClassNameStrings</code> is a boolean attribute (valid values: <code>true</code>/<code>false</code>)
  that determines whether yGuard should try to replace hardcoded Strings, which
  are used in conjunction with the <code>MyClass.class</code> construct.
  If set to <code>false</code> (the default), those Strings will be left
  untouched and code of the form <code>MyClass.class</code> will break if
  MyClass gets obfuscated by name. If set to <code>true</code> yGuard will try
  to workaround this problem by replacing the hardcoded String with the
  appropriate obfuscated name. However this will only work if the unobfuscated
  class file has been generated with the usual compilers ('javac', 'jikes' and 
  'bjc') or compilers, that produce similar bytecode. This can also have the
  side-effect of modifying too many Strings, e.g if you have code that looks like
  <code>System.out.println("com.mycompany.MyClass");</code>, it might get
  replaced, if <code>MyClass.class</code> resides in the very same class with
  something like <code>System.out.println("com.A.OoO");</code>. It will most 
  likely fail if the class has been previously obfuscated by another obfuscation
  tool or a different compiler has been used for compilation. Anyway it is 
  always worth it to give it a try, if you want to have 'full obfuscation'.
  </li> 
 </ul>
</div>
  <a name="inoutpair"></a>
 <h1>The <code>inoutpair</code> Elements</h1>
<div class="standardtext">
 <p>
 At least one <code>inoutpair</code> element has to be specified in order
 to run the obfuscation task. This elements specifies the jar files, that
 contain the class files, that should be obfuscated and the name of the 
 jar file, that will be created during the obfuscation process.
 Note that only class files will be used for obfuscation, other files
 (resources, ...) will be simply copied from the source jar to the target
 jar.<br/>
 This element has two mandatory attributes:
 </p>
 <ul>
  <li>The <code>in</code> attribute specifies an exisiting jar file, which
    contains the unobfuscated .class files.
  </li>
  <li>The <code>out</code> attribute specifies a name for a jar file, which
    will be created and used to put the results of the obfuscation process.
  </li>
 </ul>
</div>
  <a name="externalclasses"></a>
 <h1>The <code>externalclasses</code> Element</h1>
<div class="standardtext">
 <p>
 If the jar to be obfuscated depends on external classes or libraries, this
 element can be used to specify classpaths to these entities.
 These libraries will neither be modified nor obfuscated. Use the
 <code>inoutpair</code> element for this purpose!
 See the <a href="#examples">examples</a> later in this document for an example of when to use this
 element.
 <br/>
 The elements attributes and child elements can be seen on the <a
href="http://ant.apache.org/manual/using.html#path">Ant documentation
 page about using path elements</a>.
 </p>
</div>
  <a name="property"></a>
 <h1>The <code>property</code> Elements</h1>
 <div class="standardtext">
 <p>
 <code>property</code> elements can be used to give hints to the obfuscation
 engine. Depending on the exact version of yGuard, the task may use these hints
 to control the process of obfuscation.
 <br/>
 This element has two mandatory attributes:
 </p>
 <ul>
  <li>The <code>name</code> attribute specifies a key which may be interpreted
    by the obfuscation task.
  </li>
  <li>The <code>value</code> attribute specifies the corresponding value of the
    property.
  </li>
 </ul>
<p>
 As of yGuard version 1.3, the following attributes are supported:
</p>
 <ul>
  <li>The <code>error-checking</code> attribute can be used to tell yGuard 
  to bail out if it detects any problems. Currently this property can
  be set to the following value:
  <ul>
    <li>
        <code>pedantic</code> will make the obfuscation run fail, i.e. the
        target which uses the <code>obfuscate</code> element will fail, if
        yGuard detects any problems.
    </li>
  </ul>
  <li>The <code>naming-scheme</code> attribute can be used to tell yGuard to use
  a different naming scheme during the obfuscation. Currently this property can
  be set to one of the following values:
  <ul>
    <li>
        <code>small</code> will produce very short names, i.e. the resulting jar
        file will be as small as possible.
    </li>
    <li>
        <code>best</code> will produce names, that are very likely to be
        misunderstood by decompilers and disassemblers. Using this naming-scheme
        it is even impossible on most filesystems to successfully unjar or unzip the 
        resulting jar file (Windows, Standard Unix, Standard Linux, MacOS).
        However this scheme takes up a lot of space and the resulting jar is likely to
        become large (typically roughly double the size).
    </li>
    <li>
        <code>mix</code> is a mixture of both the other two values, which leads
        to reasonable small but still hard to decompile jar files.
    </li>
  </ul>
  </li>
  <li>The <code>language-conformity</code> attribute can be used to advise
    yGuard to produce names, that should be decompilable by most decompilers. On
    the other hand, yGuard can produce class files that should be executable and
    verifiable by all of todays virtual machines, but produces absolutely nonsense
    names when decompiled (Ever tried to compile '<code>int class = false.this
super(String$super.init if);</code>' ?!)
  Currently this property can
  be set to one of the following values:
  <ul>
    <li>
        <code>compatible</code> will produce names, that are ok for (most) decompilers,
        java, jar and manifest files and can be unzipped to most filesystems.
    </li>
    <li>
        <code>legal</code> will produce names, that are ok for (some) decompilers,
        java, jar and manifest files.
    </li>
    <li>
        <code>illegal</code> will produce names, that will crash some tools but
        usually <b>not</b> the jvm, but JBuilder7 in many occasions for example.
    </li>
  </ul>
  </li>
  <li>The <code>obfuscation-prefix</code> attribute can be used to instruct yGuard
  to prefix packages, that are fully obfuscated with a given package prefix, e.g. 
  <code>com.mycompany.obf</code>.
  </li>
  <li>The <code>expose-attributes</code> attribute can be used to give yGuard
  a list of attributes yGuard should expose in addition to the standard attributes.
  By default yGuard removes unneeded attributes like "Deprecated" from methods. The value
  can be a comma separated list of attributes as defined in 
  <a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#43817">
    Section 4.7 of the VM Specification of the .class File Format</a>. E.g. in order to keep 
    the "Deprecated" attribute one can add the following property:
    <br>
    <code>&lt;property name="expose-attributes" value="Deprecated"/></code>
  </li> 
 </ul>
</div>
  <a name="expose"></a>
 <h1>The <code>expose</code> Element</h1>
<div class="standardtext">
 <p>
 This element is a child of the <code>obfuscate</code> element. It can be used to 
 specify elements, that are exposed to the outside world. These can be
 classes, methods and fields.
 </p>
 <p>
 The ObfuscatorTask can be used to remove a lot of unnecessery information
 from class files, that are to be distributed and should not be decompiled.
 There are three boolean attributes, one can specify to control what information
 should be exposed (i.e. not be obfuscated or removed) by this task.
 </p>
 <ul>
   <li><code>sourcefile</code> determines whether the name of the original
    source code file should be included in the obfuscated versions of the
    classes. Default is '<code>false</code>', i.e. this information will be removed.
  </li>

   <li><code>linenumbertable</code> determines whether the line number table,
    that contains a mapping from each opcode in the class file to the line number
    in the original source code file
    should be included in the obfuscated versions of the
    classes. Default is '<code>false</code>', i.e. this information will be removed.
  </li>
   <li><code>localvariabletable</code> determines whether the local variable table,
    that contains a mapping from each local variable in the class file 
    to the name that has been used 
    in the original source code file
    should be included in the obfuscated versions of the
    classes. Default is '<code>false</code>', i.e. this information will be removed.
  </li>
 </ul>
</div>
  <a name="class"></a>
 <h1>The <code>class</code> Element</h1>
<div class="standardtext">

 <p>
  The <code>class</code> element can be used to expose classes, i.e. to exclude their names
 and/or their methods and fiels from the obfuscation process.
 </p>
 <p>
 There are two attributes, which determine what to do with the methods and
 fields of the specified class:
 </p>
 <ul>
 <li><code>methods</code> determines what methods will be exposed, depending
 on their visibility</li>

 <li><code>fields</code> determines what methods will be exposed, depending
 on their visibility</li>
 </ul>
 <p>
 The <code>methods</code>, <code>fields</code> and <code>classes</code> 
 (see the following paragraphs) determine what elements get exposed during
 obfuscation. The following table lists the possible values for all of these
 attributes and shows which elements will be exposed. A '*' denotes, that 
 elements, which have the given visibility will be exposed, for the specified
 attribute value. A '-' denotes, that the obfuscator tries to obfuscate these
 elements.
 </p> 
 <table>

 <tr>
  <th>Value/Visibility</th>
   <th><code>public</code></th>
   <th><code>protected</code></th>
   <th><code>friendly</code></td>
   <th><code>private</code></th>

 </tr>
 <tr>
   <th><code>none</code></th>
   <td align="center">-</td>
   <td align="center">-</td>
   <td align="center">-</td>
   <td align="center">-</td>

 </tr>
 <tr>
   <th><code>public</code></th>
   <td align="center">*</td>
   <td align="center">-</td>
   <td align="center">-</td>
   <td align="center">-</td>

 </tr>
 <tr>
   <th><code>protected</code></th>
   <td align="center">*</td>
   <td align="center">*</td>
   <td align="center">-</td>
   <td align="center">-</td>

 </tr>
 <tr>
   <th><code>friendly</code></th>
   <td align="center">*</td>
   <td align="center">*</td>
   <td align="center">*</td>
   <td align="center">-</td>

 </tr>
 <tr>
   <th><code>private</code></th>
   <td align="center">*</td>
   <td align="center">*</td>
   <td align="center">*</td>
   <td align="center">*</td>

 </tr>
 </table>
 <p>
 There are three possible ways of specifying classes.
 </p>
 <p>
 <ol>
 <li>One can specify a java class using the fully qualified name 
 in java syntax with the name attribute. For example:
 <pre>&lt;class name="mypackage.MyClass"/></pre></li>
 <li>One can specify multiple java classes using a modified version of 
 a patternset. The patternset's includes and excludes element should use
 java syntax, but the usual wildcards are allowed. Some examples:
 <pre>

  &lt;class>
    &lt;patternset>
      &lt;include name="com.mycompany.**.*Bean"/>
      &lt;exclude name="com.mycompany.secretpackage.*"/>
      &lt;exclude name="com.mycompany.myapp.SecretBean"/>
    &lt;/patternset>
  &lt;/class>
 </pre> This will expose all classes which reside in the package subtree
 of com.mycompany and whose name ends with Bean except for those, that
 reside in the com.mycompany.secretpackage package and the single SecretBean
 in com.mycompany.myapp .
 <pre>
  &lt;class>
    &lt;patternset>
      &lt;include name="com.mycompany.myapp.MainClass"/>
      &lt;include name="org.w3c.sax?."/>
      &lt;exclude name="org.w3c.sax?.**.*$$*"/>
    &lt;/patternset>
  &lt;/class>
 </pre> This will expose the MainClass class
 and all classes, which reside in packages like org.w3c.sax1, org.w3c.sax2, org.w3c.saxb
 except for inner classes. '$' is used as a separator between outer class names
 and inner class names. Since Ant uses '$' as an escape character, you have to
 use two consecutive '<code>$</code>'s ('<code>$$</code>') if you want to pass 
 one as an argument to the task.
 </li>

 <li>
 Finally one can specify classes depending on their visibility, i.e. depending 
 whether they have been declared <code>public</code>, <code>protected</code>, package friendly
 or <code>private</code> (inner classes). This can be achieved by
 additionally specifying the <code>classes</code> attribute in the <code>class</code> element.
 <pre>
   &lt;class classes="protected">
    &lt;patternset>
      &lt;include name="com.mycompany.myapi."/>
    &lt;/patternset>
   &lt;/class>
 </pre>

 This will expose all class names, that are either <code>public</code> or 
 <code>protected</code> and
 which reside in one of the subpackages of <code>com.mycompany.myapi</code>
 (note the 
 abbreviation: the trailing dot behaves like the trailing '<code>/</code>' in the usual
 <code>patternset</code>, i.e. it could be rewritten as <code>com.mycompany.myapi.**.*</code>)
 <pre>
   &lt;class classes="protected" 
             methods="protected" 
             fields="protected">
    &lt;patternset>
      &lt;include name="**.*"/>
    &lt;/patternset>
   &lt;/class>
 </pre>
 This example shows the very common use case of exposing a complete public API.
 There is an abbreviation for this
 use case: you can omit the <code>patternset</code> element, since in the case where the 
 <code>classes</code> attribute is specified and there is no 
 <code>patternset</code> child
 element used, the task will automatically apply this rule. In this example
 all classes will be exposed, that are either public or protected.
 Their methods and fields will be exposed  as long as they are declared
 <code>public</code> or <code>protected</code>. If a class is package friendly 
 or <code>private</code> (inner classes), neither itself
 nor its methods or fields will be exposed.

<p>

The last example shows how to expose the public methods of certain classes only, but 
neither field names nor the class names themselves. 

 <pre>
   &lt;class classes="none" methods="public" fields="none">
    &lt;patternset>
      &lt;include name="com.mycompany.myapi."/>
    &lt;/patternset>
   &lt;/class>
 </pre>

 
 </li>

 </ol>
</div>
  <a name="method"></a>
 <h1>The <code>method</code> Element</h1>
<div class="standardtext">
 <p>
 Using the <code>method</code> element you can specify methods by signature
 which should be exposed, i.e. left unobfuscated.
 This element has two attributes:
 </p>
 <ul>

  <li>
    The <code>class</code> attribute specifies the class which contains the
    method. Use the normal java syntax, i.e. the fully qualified name.
    This attribute can be omitted, if the patternset element is used as
    a child element, in which case the all classes matching the patternset 
    will be searched and their corresponding methods will be exposed.
  </i>
  <li>
    The <code>name</code> attribute specifies the method to expose. Use the
    complete signature using fully qualified class names and the return type!
  </li>
 </ul>

 <p>
 Some examples:
 </p>
 <pre>
  &lt;method class="com.mycompany.myapp.MyClass" 
             name="void main(java.lang.String[])"/>
  &lt;method class="com.mycompany.myapp.MyClass" 
             name="int foo(double[][], java.lang.Object)"/>
  &lt;method name="void writeObject(java.io.ObjectOutputStream)">
   &lt;patternset>
    &lt;include name="com.mycompany.myapp.data.*"/>
   &lt;/patternset>
  &lt;/method>
  &lt;method name="void readObject(java.io.ObjectInputStream)">
   &lt;patternset>
    &lt;include name="com.mycompany.myapp.data.*"/>
   &lt;/patternset>
  &lt;/method>
 </pre>

 <p>
  This will expose the main method of the MyClass class and the foo method.
  Additionally all readObject and writeObject methods (used for Serialization) 
  will be exposed in all classes of the com.mycompany.myapp.data package.
  Note that you have to specify the return argument's type, even if it is void
  and that you have to use the fully qualified name for all classes, even those,
  that are in the java.lang package.
 </p>
</div>
  <a name="field"></a>

 <h1>The <code>field</code> Element</h1>
<div class="standardtext">
 <p>
 Using the <code>field</code> element you can specify fields by name
 which should be exposed, i.e. left unobfuscated.
 This element has two attributes:
 </p>

 <ul>
  <li>
    The <code>class</code> attribute specifies the class which contains the
    field. Use the simple name of the field.
    This attribute can be omitted, if the patternset element is used as
    a child element, in which case the all classes matching the patternset 
    will be searched and their corresponding methods will be exposed.
  </i>
  <li>
    The <code>name</code> attribute specifies the field to expose. Use the name
    of the field only, do not include its type!
  </li>

 </ul>
 <p>
 Some examples:
 </p>
 <pre>
  &lt;field class="com.mycompany.myapp.MyClass" name="field"/>
  &lt;field name="serialVersionUID">
   &lt;patternset>
    &lt;include name="com.mycompany.myapp.data.*"/>
   &lt;/patternset>
  &lt;/field>
 </pre>

 <p>
  This will expose the field named 'field' of the MyClass class.
  Additionally all the serialVersionUID fields (used for Serialization) 
  will be exposed in all classes of the com.mycompany.myapp.data package.
 </p>
  <a name="map"></a>
</div>

  <a name="adjust"></a>

 <h1>The <code>adjust</code> Element</h1>
<div class="standardtext">
 <p>
 Using the <code>adjust</code> element one can specify resource files whose names and/or
 contents should be adjusted to reflect the obfuscated class names. 

 This element has three attributes:
 </p>

 <ul>

  <li>
    The boolean <code>replaceName</code> attribute specifies whether or not the names of 
    the specified resources should be adjusted. By default this value is set to <code>false</code>.
  </li>
  <li>
    The boolean <code>replaceContent</code> attribute specifies whether or not the contents of 
    resource files should be adjusted. By default this value is set to <code>false</code>.
  </li>
  <li>
    The boolean <code>replacePath</code> attribute specifies whether or not the paths to the 
    resource files should be adjusted. By default this value is set to <code>true</code>.
  </li>

 </ul>
 <p>
 Some examples:
 </p>
 <pre>
  &lt;!-- adjust the names of all java property files -->
  &lt;adjust replaceName="true">
   &lt;include name="**/*.properties"/>
  &lt;/adjust>

  &lt;!-- adjust the classnames specified within a single XML file -->
  &lt;adjust file="plugins.xml" replaceContent="true" />

  &lt;!-- suppress the adjustment of the resource path 
          com/mycompany/myapp/resource. -->
  &lt;!-- the package <i>com.mycompany.myapp</i> still gets obfuscated. -->
  &lt;adjust replacePath="false">
   &lt;include name="com/mycompany/myapp/resource/*"/>
  &lt;/adjust>

  
 </pre>

 </p>
  <a name="map"></a>
</div>

<h1>The <code>map</code> Element</h1>
<div class="standardtext">
 <p>The <code>map</code> element is an immediate optional child of the 
 <code>obfuscate</code> element. It can be used to specify the mapping
 for the obfuscation process directly. This is an advanced topic.</p>

 <p>
 The element can have for different kinds of child elements.
 </p>
 <ul>
 <li>
  The <code>package</code> element can be used to specify the obfuscated name for the
  given package. Note that only the last path element, i.e. the innermost subpackage
  name will be affected.
 </li>
 <li>

  The <code>class</code> element can be used to specify the obfuscated name for the
  given class. Note that only the class name, not its package path will be modified.
 </li>
 <li>
  The <code>method</code> element can be used to specify the obfuscated name for the
  given method in a class.
 </li>
 <li>
  The <code>field</code> element can be used to specify the obfuscated name for the
  given field in a class.
 </li>

 </ul>
 <p>
 All of these elements use the <code>name</code> attribute to specify the specific
 element. The <code>method</code> and <code>field</code> element need the
 <code>class</code> attribute in order to function properly. Neither wildcards
 nor nested <code>patternset</code> elements are allowed.
 Use the <code>map</code> attribute to specify the new name (subpackage, classname,
 methodname and fieldname respectively). <br/>

 Some examples:
 </p>
 <pre>
  &lt;map>
    &lt;package name="com" map="etc"/>
    &lt;package name="com.mycompany" map="nocompany"/>
    &lt;package name="com.mycompany.myapp" map="asdf"/>
    &lt;class name="com.mycompany.myapp.MainApp" map="foo"/>
    &lt;method class="com.mycompany.myapp.MainApp" 
               name="void main(java.lang.String[])" map="bar"/>
    &lt;field class="com.mycompany.myapp.MainApp" name="field" map="a"/>
  &lt;/map>
 </pre>
 <p>

  In this example the package structure 'com.mycompany.myapp' will be obfuscated to
  'etc.nocompany.asdf'. The MainApp class will be called 'foo' and its main method
  will be remapped to 'bar' (and can therefor not be executed from commandline anymore).
  The field called 'field' will be renamed to 'a'.
 </p>
</div>
  <a name="patch"></a>
 <h1>Generating Patch Jars</h1>
<div class="standardtext">
 <p>
 The true power of the <code>map</code> element lies in its use together
 with the <code>patch</code> element, which itself is a child element
 of the <code>obfuscate</code> top level element.
 </p>

 <p>
 Using the <code>patch</code> element one can generate jars, that can be used
 to serve as patches for versions of an application that have already been 
 deployed in obfuscated form.
 During the main obfuscation run, yGuard produces an xml-logfile, in which
 the mapping between the unobfuscated and obfuscated names is contained.
 The <code>patch</code> element is used to declare a set of classes, that need
 to be patched. During the obfuscation, yGuard will include those files
 in the obfuscated jars only, that are declared inside this element.<br>
 For example:
 </p>
 <pre>
  &lt;patch>
    &lt;class name="com.mycompany.myapp.MainClass"/>
    &lt;class>
      &lt;patternset>
        &lt;include name="com.mycompany.myapp.bugs.*"/>
      &lt;/patternset>
    &lt;/class>
  &lt;/patch>
  &lt;map logfile="yguardlog.xml"/>
 </pre>

 <p>
 This will only include the MainClass class and all classes that belong to the
 bugs package in a patch jar.
 In order to work with the previously delivered obfuscated version, it is 
 important to use the <code>map</code> element to specify the mapping of the elements
 from the previous run. This can most conveniently be achieved by 
 specifying the log file from the corresponding run in the map's logfile attribute.
 </p>
  <a name="examples"></a>
</div>
 <h1>Complete Examples</h1>
<div class="standardtext">
 <p>
 There will be some examples given, that represent common use cases.
 </p>
 <h2>Example 1: Getting started with ANT and yGuard (for ANT newbies)</h2>
 <p>
 Following are the contents of a complete <code>build.xml</code> file. 
 Just copy the following lines to a new document named <code>build.xml</code>
 and put the file into your project's root directory.
 </p>
 <pre>
    &lt;?xml version="1.0" encoding="UTF-8"?>
    &lt;!-- file build.xml in your project root directory -->

    &lt;!-- ANT build script for yfiles                       -->
    &lt;!-- The java based ANT tool is available from         -->
    &lt;!-- http://jakarta.apache.org/ant                     -->
    &lt;!-- This file demonstrates the use of the yGuard byte -->
    &lt;!-- code obfuscator from yWorks Gmbh                  -->
    &lt;!-- yGuard can be downloaded from                     -->
    &lt;!--- http://www.yworks.com/products/yguard            -->

    &lt;project name="project" default="obfuscate" basedir=".">

    &lt;!-- edit the following lines to your needs            -->
    &lt;target name="init">
        &lt;property name="project_name"   value="DemoProject"/>
        &lt;property name="srcDir"         value="."/>
        &lt;property name="classDir"       value="classes"/>
        &lt;property name="jar"            value="${project_name}.jar"/>
        &lt;property name="obfjar"         value="${project_name}_obf.jar"/>
        &lt;property name="obfuscationlog" value="${project_name}_obflog.xml"/>
        &lt;property name="mainclass"      value="com.mycompany.myapp.Main"/>
        &lt;mkdir dir="${classDir}" />
    &lt;/target>


    &lt;!-- obfuscate -->
    &lt;target depends="jar" name="obfuscate">
    &lt;taskdef name="obfuscate" classname="com.yworks.yguard.ObfuscatorTask" 
            classpath="yguard.jar"/>
        &lt;!-- the following can be adjusted to your needs -->
        &lt;obfuscate mainclass="${mainclass}" logfile="${obfuscationlog}"
                replaceclassnamestrings="true">
           &lt;property name="error-checking" value="pedantic"/>
           &lt;inoutpair in="${jar}" out="${obfjar}"/>
           &lt;expose>
              &lt;class classes="protected" 
                        methods="protected" fields="protected">
                    &lt;patternset>
                        &lt;include name="com.mycompany.publicapi.**.*"/>
                        &lt;exclude name="com.mycompany.publicapi.private.*"/>
                    &lt;/patternset>
                &lt;/class>
            &lt;/expose>
        &lt;/obfuscate>
    &lt;/target>

    &lt;!-- compile -->
    &lt;target name="compile" depends="init">
        &lt;javac srcdir="${srcDir}" includes="com/mycompany/**/*.java" 
            destdir="${classDir}">
       &lt;/javac>
    &lt;/target>

    &lt;!-- create .jar -->
    &lt;target name="jar" depends="compile">
            &lt;jar jarfile="${jar}"
                    basedir="${classDir}"
                    includes="com/mycompany/**">
              &lt;fileset dir="${srcDir}">
                &lt;include name="com/mycompany/resources/*.properties"/>
              &lt;/fileset>
            &lt;/jar>
    &lt;/target>

    &lt;!-- run project -->
    &lt;target name="run" depends="obfuscate">
            &lt;java classname="${mainclass}" fork="true">
                    &lt;classpath>
                      &lt;pathelement location="${obfjar}"/>
                    &lt;/classpath>
            &lt;/java>
    &lt;/target>

    &lt;!-- removes all that has been built -->
    &lt;target name="clean" depends="init">
            &lt;delete dir="${classDir}" includeEmptyDirs="true" />
    &lt;/target>
    &lt;/project>

    &lt;!-- end file build.xml -->
 </pre>
 <h2>Example 2: A Public API</h2>
<p>
    An alternative <code>obfuscate</code> section could look like this:
</p>
 <pre>
  &lt;obfuscate mainclass="com.mycompany.myapp.Main" logfile="log.xml">
    &lt;inoutpair in="classes.jar" out="classes_obf.jar"/>
    &lt;inoutpair in="utils.jar" out="utils_obf.jar"/>
    &lt;!-- don't let the obfuscator remove the "Deprecated" -->
    &lt;!-- attributes from the .class file entries          -->
    &lt;property name="expose-attributes" value="Deprecated"/>
    &lt;expose>
      &lt;class classes="protected" 
                methods="protected" 
                fields="protected"/>
    &lt;/expose>
  &lt;/obfuscate>
 </pre>
 <p>
  This case is especially useful when you want to provide and expose a public API.
  All the classes, methods and fields, that can be seen in a javadoc generated
  API will be exposed. Package friendly and private classes, methods and fields
  will be obfuscated whenever possible.<br>
  This example also displays the use of the "expose-attributes" property. In this
  case it prevents the obfuscator from removing the "Deprecated" flag from 
  the entities in the .class files.
 </p>
 <h2>Example 3: A Demo Program</h2>

 <pre>
  &lt;obfuscate mainclass="com.mycompany.myapp.Main" logfile="log.xml"
        replaceclassnamestrings="true">
    &lt;inoutpair in="demo.jar" out="demo_obf.jar"/>
    &lt;property name="language-conformity" value="illegal"/>
    &lt;property name="naming-scheme" value="mix"/>
    &lt;expose>
      &lt;!-- needed for reflection -->
      &lt;class name="com.mycompany.myapp.data.DataObject" 
                methods="public" fields="none"/>
      &lt;!-- needed for reflection (name only) -->
      &lt;class name="com.mycompany.myapp.data.InnerDataObject"/>
      &lt;!-- needed for serialization -->
      &lt;method name="void writeObject(java.io.ObjectOutputStream)">
        &lt;patternset>
          &lt;include name="com.mycompany.myapp.data.*"/>
        &lt;/patternset>
      &lt;/method>
      &lt;method name="void readObject(java.io.ObjectInputStream)">
        &lt;patternset>
          &lt;include name="com.mycompany.myapp.data.*"/>
        &lt;/patternset>
      &lt;/method>
      &lt;field name="serialVersionUID">
        &lt;patternset>
          &lt;include name="com.mycompany.myapp.data.*"/>
        &lt;/patternset>
      &lt;/field>
    &lt;/expose>
  &lt;/obfuscate>
 </pre>

 <h2>Example 4: A Program Using an External Library</h2>

 <pre>
  &lt;obfuscate mainclass="com.mycompany.myapp.Main" logfile="log.xml"
        replaceclassnamestrings="true">
    &lt;inoutpair in="mydemo.jar" out="mydemo_obf.jar"/>
    &lt;property name="error-checking" value="pedantic"/>
    &lt;externalclasses>
        &lt;pathelement location="lib/external.jar"/>
        &lt;pathelement location="lib/additional/classes/"/>
    &lt;/externalclasses>
    &lt;expose>
      &lt;class classes="public"/>
    &lt;/expose>
  &lt;/obfuscate>
 </pre>

 <p>
 This example demonstrates full method and field obfuscation for a program, that
 has external dependencies. The dependencies are specified in the
 <code>externalclasses></code> element using standard Ant path specification
 mechanisms. Classes residing in <code>lib/external.jar</code> and underneath
 the <code>lib/additional/classes/</code> directory (note the trailing slash),
 will be used to resolve external dependencies during the obfuscation run.
 This is necessary if external classes want to access obfuscated classes
 directly using an externally defined interface or superclass. yGuard
 automatically detects externally declared methods and prevents obfuscation of
 these items. As a result, the obfuscated jar can be used together with
 unmodified versions of external libraries without causing any problems.
<br>
 This example also demonstrates the use of the <code>error-checking</code>
 property. In this case the Ant target fails if any problem is detected during
 the obfuscation run.
 </p>
<h2>Example 5: A Program with <code>.properties</code> Files and Other Resource Files</h2>

 <pre>
  &lt;obfuscate mainclass="com.mycompany.myapp.Main" logfile="log.xml"
        replaceclassnamestrings="true">
    &lt;inoutpair in="myapp.jar" out="myapp_obf.jar"/>
    &lt;adjust replaceContent="true">
        &lt;!-- plain-text class names in the config files will -->
        &lt;!-- be replaced with the obfuscated name versions   -->
        &lt;include name="**/*.config"/>
        &lt;include name="com/mycompany/myapp/init/Main.properties"/>
    &lt;/adjust>
    &lt;adjust replacePath="false">
        &lt;!-- keep the complete path to the resources, (gifs...) even if -->
        &lt;!-- package com.mycompany.myapp gets obfuscated by name        -->
        &lt;include name="com/mycompany/myapp/resources/*"/>
    &lt;/adjust>
    &lt;adjust replaceName="true">
        &lt;!-- Replace the .properties files' names with the obfuscated  -->
        &lt;!-- versions if the corresponding .class files get obfuscated -->
        &lt;include name="**/*.properties"/>
    &lt;/adjust>
  &lt;/obfuscate>
 </pre>
 <p>
 This example, too, demonstrates full method and field obfuscation for a program, that
 uses .properties files and other resources files.
 Some configuration files are used that contain fully qualified classnames 
 for plugins that are going to be obfuscated. Therefor yGuard is instructed to
 automatically replace the plain-text entries in those files with the obfuscated
 name versions.
 <br>
 Additionally some resources are hardcoded into the classes (image locations
 and html files, e.g.). yGuard gets instructed not to move these resource files
 even if they reside in a package structure that is obfuscated.
 <br>
 Since the property files have been created with the same name as the classes
 that make use of them and they are being loaded using <code>this.getClass().getName()</code>,
 yGuard is configured to rename the .properties files according to the obfuscated
 names of the corresponding .class files.
  </p>
</div>
 
<a name="hints"></a>

 <h1>General Hints</h1>
<div class="standardtext">
 <p>There are a couple of things you should be aware of, when obfuscating 
 software.  You can find a lot of information on 
 <a href="http://www.retrologic.com">http://www.Retrologic.com</a>. This is
 the site which hosts 'Retroguard'. The yGuard <i>library</i> has been derived from Retroguard.
 The most important facts are described here briefly:
 </p>
 <ul>
  <li>Code in the form of <code>MyApplication.class</code> will break in the 
  if MyApplication will be obfuscated by name
  and the obfuscation switch <code>replaceClassNameStrings</code> is <b>not</b> set or 
  set to a value of
  <code>false</code>. See <a href="#obfuscate"><code>obfuscate</code></a> for
  more information about that switch.
   </li>
  <li>Automatic introspection and reflection will break in most cases, when 
  you decide to obfuscate the corresponding methods and fields.
   </li>
  <li><code>Class.forName(className)</code> will not work unless you use the
  obfuscated name string in your variable or the String is a local constant and
  <code>replaceClassNameStrings</code> is set to <code>true</code>.
  <li>The customized serialization mechanism will not work if you
  obfuscated the writeObject and readObject methods.
  </li>
  <li>Simple bean introspection will not work, if you decide to 
  obfuscate your public methods, since it makes use of 
  reflection.
  </li>
 </ul>
</div>
<a name="problems"></a>
 <h1>Problems and Bug Reports</h1>
<div class="standardtext">
    <p>
    If you experience any problems or think you have found a bug feel free to send
    an email to <a href="mailto:yguard@yworks.com">yguard@yworks.com</a> but
    please make sure you have read the documentation thoroughly before. We will
    do our best and try to answer your questions.
    </p>
</div>
</body>
</html>
<!-- EOF -->
